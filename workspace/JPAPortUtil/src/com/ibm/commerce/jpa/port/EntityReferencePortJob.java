package com.ibm.commerce.jpa.port;

/*
 *-----------------------------------------------------------------
 * Copyright 2018
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *     http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *-----------------------------------------------------------------
 */

import java.util.Collection;
import java.util.Collections;
import java.util.HashSet;
import java.util.Set;

import org.eclipse.core.resources.IFile;
import org.eclipse.core.resources.IProject;
import org.eclipse.core.resources.IWorkspace;
import org.eclipse.core.resources.IWorkspaceRoot;
import org.eclipse.core.resources.IncrementalProjectBuilder;
import org.eclipse.core.resources.ResourcesPlugin;
import org.eclipse.core.runtime.CoreException;
import org.eclipse.core.runtime.IProgressMonitor;
import org.eclipse.core.runtime.IStatus;
import org.eclipse.core.runtime.Status;
import org.eclipse.core.runtime.SubProgressMonitor;
import org.eclipse.core.runtime.jobs.Job;
import org.eclipse.jdt.core.IJavaProject;
import org.eclipse.jdt.core.JavaCore;
import org.eclipse.jdt.core.dom.AST;
import org.eclipse.jdt.core.dom.ASTParser;

import com.ibm.commerce.jpa.port.generators.EntityReferencingProjectGenerator;
import com.ibm.commerce.jpa.port.info.ApplicationInfo;
import com.ibm.commerce.jpa.port.info.ModuleInfo;
import com.ibm.commerce.jpa.port.info.ProjectInfo;
import com.ibm.commerce.jpa.port.parsers.ModuleInfoXmlParser;
import com.ibm.commerce.jpa.port.parsers.ProjectInfoXmlParser;
import com.ibm.commerce.jpa.port.util.BackupUtil;
import com.ibm.commerce.jpa.port.util.EntityReferenceUtil;
import com.ibm.commerce.jpa.port.util.JPASeederUtilBase;
import com.ibm.commerce.jpa.port.util.ResolveImportsUtil;

/**
 * This job replaces references to the EJB entities/AB with references to the matching JPA entity/AB.
 * See the comments in the run method for details on how it works.
 * 
 * Note that this job requires the .jpaModuleInfo.xml metafile to exist, so JPAGenerateJob must be run before this job.
 * Note that this job requires these files to exist before it can run successfully - 
 * 				.jpaAccessBeanSubclassInfo.xml
 *		  		.jpaEntityReferences.xml
 *			  	.jpaEntityReferenceSubclasses.xml
 *	these files are generated by the *SearchJobs, so those just must be run before this job.
 */
public class EntityReferencePortJob extends Job {
	private static final int PARALLEL_JOBS = 4;
	private IWorkspace iWorkspace;
	private ApplicationInfo iApplicationInfo = new ApplicationInfo();
	private IProgressMonitor iProgressGroup;
	private Collection<IProject> iBuildPendingProjects = Collections.synchronizedCollection(new HashSet<IProject>());
	
	public EntityReferencePortJob() {
		super("Entity Reference Port");
		iWorkspace = ResourcesPlugin.getWorkspace();
		iProgressGroup = Job.getJobManager().createProgressGroup();
		setProgressGroup(iProgressGroup, 50200);
	}
	
	public IStatus run(IProgressMonitor progressMonitor) {
		IStatus status = Status.OK_STATUS;
		try {
			iProgressGroup.beginTask("Update Entity References", 50200);
			progressMonitor.beginTask("Update Entity References", 50200);
			
			//creates an empty application info
			initializeApplicationInfo();					// 0 ticks
			
			 //Deletes all files that are recorded in the .jpaGeneratedFileList2 metadata file for the project.
			 //Then copies all folders and files from the metadata backup directory, .jpaBackup2, to their original location(s) in the project.
			 //It then deletes the metadata backup directory.
			restoreProjects(progressMonitor);				// 1000 ticks
			
			//WCE doesn't need this - we will add the v9 compiled jars to our CP
			//seedNewClasses(progressMonitor, "SeedClasses2/projects"); // 100 ticks
			
			//builds all projects that had restore activity 
			buildProjects(progressMonitor);				// 5000 ticks
			
			//parse the .jpaModuleInfo.xml file contents (for all projects where it exists)
			//this file is created by the JPAGenerateJob, so that job needs run first
			parseModules(progressMonitor);				// 5000 ticks
			
			//parses these 3 files
			//	.jpaAccessBeanSubclassInfo.xml
			//  .jpaEntityReferences.xml
			//  .jpaEntityReferenceSubclasses.xml
			//These files are generated by the *SearchJob classes, so those jobs must be run first
			parseProjects(progressMonitor);				// 5000 ticks
			
			
			portProjects(progressMonitor);				// 20000 ticks
			
			//WCE doesn't need this - we will add the v9 compiled jars to our CP
			//seedNewClasses(progressMonitor, "SeedClasses3/projects"); // 100 ticks
			
			
			iApplicationInfo.printSummary();
			iApplicationInfo = null;
			
			//triggers a build on all projects that had references generated
			buildProjects(progressMonitor);				// 5000 ticks
			
			//resolves any new imports that are necessary
			resolveImports(progressMonitor);				// 1000 ticks
			
			//builds all projects now that imports are correct
			buildProjects(progressMonitor);				// 5000 ticks
			
			
			//the next two steps attempt to compile the "Catalog-Server-FEP" project only - WCE should not need this - it will never trigger
			//any meaningful action anyway, as that project doesn't exist
			//determineFinalPassBuildProjects(); // 0 ticks
			//buildProjects(progressMonitor);				// 5000 ticks
		}
		catch (InterruptedException e) {
			status = Status.CANCEL_STATUS;
		}
		finally {
			progressMonitor.done();
			iProgressGroup.done();
		}
		return status;
	}

	private void initializeApplicationInfo() {
		iApplicationInfo = new ApplicationInfo();
	}

	private void determineFinalPassBuildProjects() {
		IWorkspaceRoot root = iWorkspace.getRoot();
		IProject[] projects = root.getProjects();
		for (IProject project : projects) {
			if (project.getName().equals("Catalog-Server-FEP")) {
				iBuildPendingProjects.add(project);
			}
		}
	}
	
	private void restoreProjects(IProgressMonitor progressMonitor) throws InterruptedException {
		IWorkspaceRoot root = iWorkspace.getRoot();
		IProject[] projects = root.getProjects();
		Set<IProject> projectSet = new HashSet<IProject>();
		for (IProject project : projects) {
//			if (project.getName().equals("Analytics-BusinessIntelligenceLogic") || project.getName().equals("Enablement-BaseComponentsLogic") || project.getName().equals("Marketing-CampaignsAndScenarioMarketingLogic"))
			if(project.isOpen()) {
				projectSet.add(project);
			}
		}
		Set<RestoreProjectJob> restoreProjectJobs = new HashSet<RestoreProjectJob>();
		for (int i = 0; i < PARALLEL_JOBS; i++) {
			RestoreProjectJob restoreProjectJob = new RestoreProjectJob(iApplicationInfo, iBuildPendingProjects, projectSet);
			restoreProjectJob.setProgressGroup(iProgressGroup, 1000 / PARALLEL_JOBS);
			restoreProjectJob.schedule();
			restoreProjectJobs.add(restoreProjectJob);
		}
		for (RestoreProjectJob restoreProjectJob : restoreProjectJobs) {
			restoreProjectJob.join();
			progressMonitor.worked(1000 / PARALLEL_JOBS);
		}
	}
	
	private void seedNewClasses(IProgressMonitor progressMonitor, String sourceFolderName) throws InterruptedException {
		if (!progressMonitor.isCanceled()) {
			SeedNewClassesJob seedNewClassesJob = new SeedNewClassesJob(iApplicationInfo, iBuildPendingProjects, sourceFolderName);
			seedNewClassesJob.setProgressGroup(iProgressGroup, 100);
			seedNewClassesJob.schedule();
			seedNewClassesJob.join();
			progressMonitor.worked(100);
		}
	}
	
	private void parseModules(IProgressMonitor progressMonitor) throws InterruptedException {
		if (!progressMonitor.isCanceled()) {
			IWorkspaceRoot root = iWorkspace.getRoot();
			IProject[] projects = root.getProjects();
			Set<ModuleInfo> modules = new HashSet<ModuleInfo>();
			for (IProject project : projects) {
				if(project.isOpen()) {
					IFile moduleInfoXmlFile = project.getFile(".jpaModuleInfo.xml");
					if (moduleInfoXmlFile.exists()) {
						IJavaProject javaProject = JavaCore.create(project);
						ModuleInfo moduleInfo = new ModuleInfo(iApplicationInfo, javaProject);
						iApplicationInfo.addModule(moduleInfo);
						modules.add(moduleInfo);
					}
				}
			}
			Set<ParseModuleJob> parseModuleJobs = new HashSet<ParseModuleJob>();
			for (int i = 0; i < PARALLEL_JOBS; i++) {
				ParseModuleJob parseModuleJob = new ParseModuleJob(modules);
				parseModuleJob.setProgressGroup(iProgressGroup, 5000 / PARALLEL_JOBS);
				parseModuleJob.schedule();
				parseModuleJobs.add(parseModuleJob);
			}
			for (ParseModuleJob parseModuleJob : parseModuleJobs) {
				parseModuleJob.join();
				progressMonitor.worked(5000 / PARALLEL_JOBS);
			}
		}
	}
	
	private void parseProjects(IProgressMonitor progressMonitor) throws InterruptedException {
		if (!progressMonitor.isCanceled()) {
			IWorkspaceRoot root = iWorkspace.getRoot();
			EntityReferenceUtil.loadPredefinedEntityReferences(iApplicationInfo, root);
			IProject[] projects = root.getProjects();
			Set<ProjectInfo> projectInfos = new HashSet<ProjectInfo>();
			for (IProject project : projects) {
				if(project.isOpen()) {
					IFile accessBeanSubclassInfoXmlFile = project.getFile(".jpaAccessBeanSubclassInfo.xml");
					IFile entityReferencesXmlFile = project.getFile(".jpaEntityReferences.xml");
					IFile entityReferenceSubclassesXmlFile = project.getFile(".jpaEntityReferenceSubclasses.xml");
					IFile generatedFileList = project.getFile(".jpaGeneratedFileList");
					if (accessBeanSubclassInfoXmlFile.exists() || entityReferencesXmlFile.exists() || entityReferenceSubclassesXmlFile.exists() || generatedFileList.exists()) {
						ProjectInfo projectInfo = iApplicationInfo.getProjectInfo(project);
						projectInfos.add(projectInfo);
					}
				}
			}
			Set<ParseProjectJob> parseProjectJobs = new HashSet<ParseProjectJob>();
			for (int i = 0; i < PARALLEL_JOBS; i++) {
				ParseProjectJob parseProjectJob = new ParseProjectJob(projectInfos);
				parseProjectJob.setProgressGroup(iProgressGroup, 5000 / PARALLEL_JOBS);
				parseProjectJob.schedule();
				parseProjectJobs.add(parseProjectJob);
			}
			for (ParseProjectJob parseProjectJob : parseProjectJobs) {
				parseProjectJob.join();
				progressMonitor.worked(5000 / PARALLEL_JOBS);
			}
		}
	}
	
	private void portProjects(IProgressMonitor progressMonitor) throws InterruptedException {
		if (!progressMonitor.isCanceled()) {
			Set<ProjectInfo> projects = new HashSet<ProjectInfo>();
			projects.addAll(iApplicationInfo.getProjects());
//			projects.add(iApplicationInfo.getProjectInfo(iWorkspace.getRoot().getProject("Analytics-BusinessIntelligenceLogic")));
//			projects.add(iApplicationInfo.getProjectInfo(iWorkspace.getRoot().getProject("Enablement-BaseComponentsLogic")));
//			projects.add(iApplicationInfo.getProjectInfo(iWorkspace.getRoot().getProject("Marketing-CampaignsAndScenarioMarketingLogic")));
			Set<PortProjectJob> portProjectJobs = new HashSet<PortProjectJob>();
			for (int i = 0; i < PARALLEL_JOBS; i++) {
				PortProjectJob portProjectJob = new PortProjectJob(projects, iApplicationInfo, iBuildPendingProjects);
				portProjectJob.setProgressGroup(iProgressGroup, 20000 / PARALLEL_JOBS);
				portProjectJob.schedule();
				portProjectJobs.add(portProjectJob);
			}
			for (PortProjectJob portProjectJob : portProjectJobs) {
				portProjectJob.join();
				progressMonitor.worked(20000 / PARALLEL_JOBS);
			}
		}
	}
	
	private void resolveImports(IProgressMonitor progressMonitor) throws InterruptedException {
		if (!progressMonitor.isCanceled()) {
			IWorkspaceRoot root = iWorkspace.getRoot();
			IProject[] projects = root.getProjects();
			Collection<IProject> projectSet = new HashSet<IProject>();
			for (IProject project : projects) {
//				if (project.getName().equals("Analytics-BusinessIntelligenceLogic") || project.getName().equals("Enablement-BaseComponentsLogic") || project.getName().equals("Marketing-CampaignsAndScenarioMarketingLogic"))
				if(project.isOpen()) {
					projectSet.add(project);
				}
			}
			Set<ResolveImportsJob> resolveImportsJobs = new HashSet<ResolveImportsJob>();
			for (int i = 0; i < PARALLEL_JOBS; i++) {
				ResolveImportsJob resolveImportsJob = new ResolveImportsJob(projectSet, iBuildPendingProjects);
				resolveImportsJob.setProgressGroup(iProgressGroup, 1000 / PARALLEL_JOBS);
				resolveImportsJob.schedule();
				resolveImportsJobs.add(resolveImportsJob);
			}
			for (ResolveImportsJob resolveImportsJob : resolveImportsJobs) {
				resolveImportsJob.join();
				progressMonitor.worked(1000 / PARALLEL_JOBS);
			}
		}
	}
	
	private void buildProjects(IProgressMonitor progressMonitor) throws InterruptedException {
		if (!progressMonitor.isCanceled()) {
			Set<BuildProjectJob> buildProjectJobs = new HashSet<BuildProjectJob>();
			for (int i = 0; i < PARALLEL_JOBS; i++) {
				BuildProjectJob buidProjectJob = new BuildProjectJob(iBuildPendingProjects);
				buidProjectJob.setProgressGroup(iProgressGroup, 5000 / PARALLEL_JOBS);
				buidProjectJob.schedule();
				buildProjectJobs.add(buidProjectJob);
			}
			for (BuildProjectJob buidProjectJob : buildProjectJobs) {
				buidProjectJob.join();
				progressMonitor.worked(5000 / PARALLEL_JOBS);
			}
		}
	}
	
	private static class RestoreProjectJob extends Job {
		private ApplicationInfo iApplicationInfo;
		private Collection<IProject> iBuildPendingProjects;
		private Set<IProject> iProjects;

		public RestoreProjectJob(ApplicationInfo applicationInfo, Collection<IProject> buildPendingProjects, Set<IProject> projects) {
			super("Restore projects");
			iApplicationInfo = applicationInfo;
			iBuildPendingProjects = buildPendingProjects;
			iProjects = projects;
		}
		
		public IStatus run(IProgressMonitor progressMonitor) {
			IStatus status = Status.OK_STATUS;
			try {
				progressMonitor.beginTask("Restore projects", IProgressMonitor.UNKNOWN);
				IProject project = getProject();
				while (project != null) {
					boolean restored = false;
					if (!progressMonitor.isCanceled()) {
						BackupUtil backupUtil = iApplicationInfo.getBackupUtil(project);
						try {
							restored = backupUtil.restore2(new SubProgressMonitor(progressMonitor, 1000));
							if (restored) {
								iBuildPendingProjects.add(project);
							}
						}
						catch (CoreException e) {
							e.printStackTrace();
							status = Status.CANCEL_STATUS;
						}
					}
					else {
						status = Status.CANCEL_STATUS;
					}
					if (status != Status.CANCEL_STATUS && !progressMonitor.isCanceled()) {
						project = getProject();
					}
					else {
						status = Status.CANCEL_STATUS;
						project = null;
					}
				}
			}
			finally {
				progressMonitor.done();
				iApplicationInfo = null;
				iBuildPendingProjects = null;
				iProjects = null;
			}
			return status;
		}
		
		private IProject getProject() {
			IProject project = null;
			synchronized(iProjects) {
				for (IProject currentProject : iProjects) {
					project = currentProject;
					break;
				}
				if (project != null) {
					iProjects.remove(project);
				}
			}
			return project;
		}
	}
	
	private static class SeedNewClassesJob extends Job {
		private ApplicationInfo iApplicationInfo;
		private Collection<IProject> iBuildPendingProjects;
		private String iSourceFolderName;
		
		public SeedNewClassesJob(ApplicationInfo applicationInfo, Collection<IProject> buildPendingProjects, String sourceFolderName) {
			super("Seed new classes");
			iApplicationInfo = applicationInfo;
			iBuildPendingProjects = buildPendingProjects;
			iSourceFolderName = sourceFolderName;
		}
		
		public IStatus run(IProgressMonitor progressMonitor) {
			System.out.println("Seed new classes");
			IStatus status = Status.OK_STATUS;
			try {
				progressMonitor.beginTask("Seed new classes", IProgressMonitor.UNKNOWN);
				if (!progressMonitor.isCanceled()) {
					JPASeederUtilBase seederUtil = new JPASeederUtilBase(iApplicationInfo, iBuildPendingProjects, iSourceFolderName, false);
					seederUtil.seedNewClasses(progressMonitor);
				}
				else {
					status = Status.CANCEL_STATUS;
				}
			}
			finally {
				progressMonitor.done();
				iApplicationInfo = null;
				iBuildPendingProjects = null;
			}
			return status;
		}
	}
	
	private static class ParseModuleJob extends Job {
		private Set<ModuleInfo> iModules;

		public ParseModuleJob(Set<ModuleInfo> modules) {
			super("Parse modules");
			iModules = modules;
		}
		
		public IStatus run(IProgressMonitor progressMonitor) {
			IStatus status = Status.OK_STATUS;
			try {
				progressMonitor.beginTask("Parse modules", IProgressMonitor.UNKNOWN);
				ModuleInfo moduleInfo = getModule();
				while (moduleInfo != null) {
					if (!progressMonitor.isCanceled()) {
						ModuleInfoXmlParser moduleInfoXmlParser = new ModuleInfoXmlParser(moduleInfo);
						moduleInfoXmlParser.parse(new SubProgressMonitor(progressMonitor, 1000));
						moduleInfo = getModule();
					}
					else {
						status = Status.CANCEL_STATUS;
						moduleInfo = null;
					}
				}
			}
			finally {
				progressMonitor.done();
				iModules = null;
			}
			return status;
		}
		
		private ModuleInfo getModule() {
			ModuleInfo module = null;
			synchronized(iModules) {
				for (ModuleInfo currentModule : iModules) {
					module = currentModule;
					break;
				}
				if (module != null) {
					iModules.remove(module);
				}
			}
			return module;
		}
	}

	private static class ParseProjectJob extends Job {
		private Set<ProjectInfo> iProjects;

		public ParseProjectJob(Set<ProjectInfo> projects) {
			super("Parse projects");
			iProjects = projects;
		}
		
		public IStatus run(IProgressMonitor progressMonitor) {
			IStatus status = Status.OK_STATUS;
			try {
				progressMonitor.beginTask("Parse projects", IProgressMonitor.UNKNOWN);
				ProjectInfo projectInfo = getProjectInfo();
				while (projectInfo != null) {
					if (!progressMonitor.isCanceled()) {
						ProjectInfoXmlParser projectInfoXmlParser = new ProjectInfoXmlParser(projectInfo);
						projectInfoXmlParser.parse(new SubProgressMonitor(progressMonitor, 1000));
						projectInfo = getProjectInfo();
					}
					else {
						status = Status.CANCEL_STATUS;
						projectInfo = null;
					}
				}
			}
			finally {
				progressMonitor.done();
				iProjects = null;
			}
			return status;
		}
		
		private ProjectInfo getProjectInfo() {
			ProjectInfo projectInfo = null;
			synchronized(iProjects) {
				for (ProjectInfo currentProject : iProjects) {
					projectInfo = currentProject;
					break;
				}
				if (projectInfo != null) {
					iProjects.remove(projectInfo);
				}
			}
			return projectInfo;
		}
	}
	
	private static class PortProjectJob extends Job {
		private Collection<ProjectInfo> iProjects;
		private ApplicationInfo iApplicationInfo;
		private Collection<IProject> iBuildPendingProjects;
		
		public PortProjectJob(Collection<ProjectInfo> projects, ApplicationInfo applicationInfo, Collection<IProject> buildPendingProjects) {
			super("Port modules");
			iProjects = projects;
			iApplicationInfo = applicationInfo;
			iBuildPendingProjects = buildPendingProjects;
		}
		
		public IStatus run(IProgressMonitor progressMonitor) {
			IStatus status = Status.OK_STATUS;
			try {
				progressMonitor.beginTask("Port projects", IProgressMonitor.UNKNOWN);
				ProjectInfo projectInfo = getProjectInfo();
				while (projectInfo != null) {
					if (!progressMonitor.isCanceled()) {
						EntityReferencingProjectGenerator entityReferencingProjectGenerator = new EntityReferencingProjectGenerator(iApplicationInfo, projectInfo);
						boolean referencesGenerated = entityReferencingProjectGenerator.generate(new SubProgressMonitor(progressMonitor, 1000));
						if (referencesGenerated) {
							iBuildPendingProjects.add(projectInfo.getProject());
						}
					}
					else {
						status = Status.CANCEL_STATUS;
						projectInfo = null;
					}
					if (!progressMonitor.isCanceled() && status != Status.CANCEL_STATUS) {
						projectInfo = getProjectInfo();
					}
					else {
						status = Status.CANCEL_STATUS;
						projectInfo = null;
					}
				}
			}
			finally {
				progressMonitor.done();
				iProjects = null;
				iApplicationInfo = null;
				iBuildPendingProjects = null;
			}
			return status;
		}
		
		private ProjectInfo getProjectInfo() {
			ProjectInfo projectInfo = null;
			synchronized(iProjects) {
				for (ProjectInfo currentProject : iProjects) {
					projectInfo = currentProject;
					break;
				}
				if (projectInfo != null) {
					iProjects.remove(projectInfo);
				}
			}
			return projectInfo;
		}
	}
	
	private static class ResolveImportsJob extends Job {
		private Collection<IProject> iBuildPendingProjects;
		private Collection<IProject> iProjects;
		private ASTParser iASTParser = ASTParser.newParser(AST.JLS3);

		public ResolveImportsJob(Collection<IProject> projects, Collection<IProject> buildPendingProjects) {
			super("Resolve imports");
			iProjects = projects;
			iBuildPendingProjects = buildPendingProjects;
		}
		
		public IStatus run(IProgressMonitor progressMonitor) {
			IStatus status = Status.OK_STATUS;
			try {
				progressMonitor.beginTask("Resolve imports", IProgressMonitor.UNKNOWN);
				IProject project = getProject();
				while (project != null) {
					if (!progressMonitor.isCanceled()) {
						ResolveImportsUtil resolveImportsUtil = new ResolveImportsUtil(iASTParser, project, project.getFile(".jpaGeneratedFileList2"));
						try {
							boolean importsResolved = resolveImportsUtil.resolveImports(new SubProgressMonitor(progressMonitor, 1000));
							if (importsResolved || project.getFolder(".jpaBackup2").exists()) {
								iBuildPendingProjects.add(project);								
							}
						}
						catch (CoreException e) {
							e.printStackTrace();
							status = Status.CANCEL_STATUS;
						}
					}
					else {
						status = Status.CANCEL_STATUS;
					}
					project = getProject();
				}
			}
			finally {
				progressMonitor.done();
				iBuildPendingProjects = null;
				iProjects = null;
				iASTParser = null;
			}
			return status;
		}
		
		private IProject getProject() {
			IProject project = null;
			synchronized(iProjects) {
				for (IProject currentProject : iProjects) {
					project = currentProject;
					break;
				}
				if (project != null) {
					iProjects.remove(project);
				}
			}
			return project;
		}
	}
	
	private static class BuildProjectJob extends Job {
		private Collection<IProject> iBuildPendingProjects;
		
		public BuildProjectJob(Collection<IProject> buildPendingProjects) {
			super("Build projects");
			iBuildPendingProjects = buildPendingProjects;
		}
		
		public IStatus run(IProgressMonitor progressMonitor) {
			IStatus status = Status.OK_STATUS;
			try {
				progressMonitor.beginTask("Build projects", IProgressMonitor.UNKNOWN);
				IProject project = getProject();
				while (project != null) {
					if (!progressMonitor.isCanceled() && status != Status.CANCEL_STATUS) {
						try {
							System.out.println("building "+project.getName());
							project.build(IncrementalProjectBuilder.INCREMENTAL_BUILD, new SubProgressMonitor(progressMonitor, 1000));
						}
						catch (CoreException e) {
							e.printStackTrace();
							status = Status.CANCEL_STATUS;
						}
					}
					else {
						status = Status.CANCEL_STATUS;
					}
					if (!progressMonitor.isCanceled() && status != Status.CANCEL_STATUS) {
						project = getProject();
					}
					else {
						project = null;
					}
				}
			}
			finally {
				progressMonitor.done();
				iBuildPendingProjects = null;
			}
			return status;
		}
		
		private IProject getProject() {
			IProject project = null;
			synchronized(iBuildPendingProjects) {
				for (IProject currentProject : iBuildPendingProjects) {
					project = currentProject;
					break;
				}
				if (project != null) {
					iBuildPendingProjects.remove(project);
				}
				else {
					System.out.println("no more build projects");
				}
			}
			return project;
		}
	}
}
